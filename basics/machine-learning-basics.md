# Machine Learning Basics

机器学习的核心是使用算法解析数据，从中学习，并使用学习到的经验预测未来。与显示的教会计算机如何执行任务不同，机器学习是从数据中自动获取经验。

## 数据分析与预处理

但是真实的训练数据可能会存在各种各样的问题：各特征(变量)的尺度(量纲)和数量级差异大、数据中存在缺失值、数据中存在异常值和错误值、存在冗余变量等。

### 特征放缩

若原始数据中各维数据特征分布范围差异大，如果直接使用原始数据来建模，会突出数值尺度较大的特征在建模中的作用，而相对削弱或忽略数值尺度较小的特征的作用。因此，为了保证模型的有效性、可靠性，需要对原始数据的特征做特征缩放，使得各维特征对目标函数有相同权重的影响。

通常为了能够消除数据不同特征的尺度差异大的影响，需要把各维特征都缩放到同一个标准时，这样才具有可比性，这个过程就是数据标准化处理。

因此，数据标准化处理的
- 目标：使各维特征的取值均在相同的范围内以去除不同尺度特征的干扰。
- 作用：加快训练速度以及避免模型被分布范围较大或较小的特征干扰


<b>归一化</b>

归一化是数据标准化处理的一种方式，将数据缩放到[0,1]或[-1,1]区间内。

- 极大极小归一化

$$
x' = \frac{x - x_{min}}{x_{max} - x_{min}}
$$

- 均值归一化

$$
x' = \frac{x - \mu}{\sigma}
$$


- 非线性归一化
非线性归一化没有把原数据各维特征缩放到某一范围内而是缩小各维特征的尺度(量纲)。平时在一些数据处理中，经常会把原始数据取对数后在做进一步处理。之所以这样做是基于对数函数在其定义域内是单调增函数，取对数之后不会改变数据的性质和相关关系，还可以压缩特征的尺度(量纲)。


归一化总结

特点：归一化会改变原始数据的数据分布，所以不能保留原始信息
对不同特征做伸缩变换，其目的是使得各个特征维度对目标函数的影响权重是同等程度的。同时，由于对不同特征做伸缩变换程度不同，使得那些扁平分布的目标函数的投影等高线趋于圆形，这样也就改变了原始数据的分布类型。
作用：
1、加快训练速度：如迭代算法中目标函数的收敛速度
2、平衡各维特征权重，避免数值尺度过大、过小的特征对模型的干扰
缺陷：
归一化处理数据后，虽然平衡了各维特征权重，但也改变了原始数据的数据分布，即破坏了数据结构。


<b>z-score</b>

z-score标准化处理数据后，数据会服从标准正态分布，即均值为0，标准差为1。

$$
x' = \frac{x - \mu}{\sigma}
$$

z-score保留原始数据信息，不会改变原数据分布类型。z-score的目的也是使原始数据的不同特征具有可比性。


<b>正则化</b>

正则化处理数据将每个样本的某个范数(L1范数、L2范数)缩放为1，即对每个样本计算其p-范数，然后对该样本中的每个元素除以该范数，使得处理后数据的每个样本的p-范数等于1。

$$
X' = \frac{X}{||X||_p}
$$

正则化处理数据主要应用于文本分类和聚类中，对需要计算样本之间相似度的模型，正则化可以提高计算效率。

### 缺失值处理

现实生活中的数据往往是不全面的，很多样本的属性值会有缺失，例如某个人填写的个人信息不完整或者对个人隐私的保护政策导致建模时可能无法得到所需要的特征，尤其是在数据量较大时，这种缺失值的产生会对模型的性能造成很大的影响。

1. 删除缺失值
2. 填补缺失值
    - 将缺失值替换为均值、中位数、众数、最大值、最小值等
    - 使用KNN算法填充：缺失样本点周围最近的k个样本的均值或最大值填充(使用前提是，数据不是连片缺失，否则缺失样本点周围的样本也有缺失值，那就用不成了)
    - 加权平均值/期望替换缺失值：比较含缺失值的样本与其他样本之间的的相似度，计算其加权平均值=Σ(特征值i*相似度i)/sum(相似度)，过程和基于用户相似度的SVD推荐系统差不多。


## 模型验证与评估

### 欠拟合与过拟合

欠拟合：模型在训练集上误差很高；

欠拟合原因：模型过于简单，没有很好的捕捉到数据特征，不能很好的拟合数据。

过拟合：在训练集上误差低，测试集上误差高；

过拟合原因：模型把数据学习的太彻底，以至于把噪声数据的特征也学习到了，这样就会导致在后期测试的时候不能够很好地识别数据，模型泛化能力太差。

解决过拟合问题：
1、增加数据量
数据收集：通过各种途径收集更多与问题相关的数据。例如，对于图像分类任务，可以从互联网上的公开图像数据集获取更多图像，或者自行采集更多符合任务要求的图像。
数据扩充：当难以获取大量真实数据时，可以采用数据扩充技术。对于图像数据，常见的扩充方法包括旋转、翻转、缩放、裁剪、添加噪声等；对于文本数据，可以进行同义词替换、随机插入、随机删除等操作来生成更多类似但又有差异的数据样本。
2、正则化
L1 和 L2 正则化：在模型的损失函数中添加正则化项。L1 正则化会促使模型的一些权重趋近于零，从而实现特征选择的效果；L2 正则化则是限制权重的平方和，使得权重的值不会过大，起到抑制过拟合的作用。在许多机器学习框架中，如在训练线性回归、逻辑回归、神经网络等模型时，都可以很方便地设置 L1 或 L2 正则化参数。
Dropout：主要应用于神经网络中。在训练过程的每次迭代中，随机地将一部分神经元的输出设置为零，这样可以防止神经元之间过度依赖特定的连接模式，从而降低模型的复杂度，减少过拟合。例如在训练深度神经网络进行图像分类时，在每一层的神经元连接中应用 Dropout 技术，通常设置一个合适的 Dropout 概率，如 0.5 等。
3、简化模型结构
减少层数或神经元数量：对于神经网络，如果模型层数过多或者每层的神经元数量过多，容易导致过拟合。可以尝试减少网络的层数，比如从一个很深的卷积神经网络去掉几层；或者降低每层神经元的数量，例如将某一层原本有 1000 个神经元减少到 500 个。
选择更简单的模型类型：如果使用的是较为复杂的模型，如深度神经网络，而数据量相对较少或问题本身相对简单，可以考虑换成更简单的模型，如线性回归（对于线性关系明显的问题）、决策树（对于可通过简单规则划分的数据）等。
4、早停法
        在模型训练过程中，随着训练轮次的增加，模型在训练集上的误差会不断降低，但在验证集上的误差可能会先降低后升高。早停法就是监测验证集上的误差，当验证集上的误差开始上升时（表明模型开始过拟合训练集），就停止训练，从而得到一个在泛化能力上相对较好的模型。例如，在训练一个深度学习模型时，每隔一定的训练轮次（如每 10 轮）就评估一次模型在验证集上的性能，一旦发现验证集性能下降，就停止训练。

解决欠拟合问题：
1、增加模型复杂度
增加层数或神经元数量：对于神经网络，若发现模型存在欠拟合，可以尝试增加网络的层数，比如在一个浅层的卷积神经网络基础上再添加几层；或者增加每层神经元的数量，例如将某一层原本有 200 个神经元增加到 400 个。
使用更复杂的模型类型：如果当前使用的是简单模型，如线性回归，而数据呈现出明显的非线性关系，那么可以考虑换成更复杂的模型，如多项式回归（在线性回归基础上增加多项式项）、神经网络等。
2、延长训练时间
        如果模型训练时间过短，可能导致模型还没有充分学习到数据中的规律，从而出现欠拟合。可以适当延长训练时间，比如将原本训练 100 轮次增加到 200 轮次，让模型有更多机会去学习数据中的模式。

3、检查数据预处理
特征工程：确保进行了充分的特征工程，例如对数据进行标准化、归一化等操作，使得数据更适合模型学习。如果数据没有经过合理的预处理，可能会影响模型的学习效果，导致欠拟合。
数据清理：检查数据中是否存在大量错误、缺失值等情况。如果有，需要进行相应的清理操作，如填充缺失值、纠正错误值等，以便模型能够更好地学习数据。
4、调整超参数
        不同的超参数设置会影响模型的学习效果。对于一些模型，如神经网络，可以调整学习率、批量大小等超参数。如果学习率过大，可能导致模型无法稳定地学习数据，出现欠拟合；如果学习率过小，又会导致训练时间过长。通过尝试不同的超参数组合，找到一个更适合的设置，有助于解决欠拟合问题。

三、偏差与方差 
1、模型误差来源
        在上一部分，我们知道了欠拟合是模型在训练集上误差过高，过拟合模型是在训练集上误差低，在测试集上误差高。那么模型误差的来源是什么呢？

        其实，模型在训练集上的误差来源主要来自于偏差，在测试集上误差来源主要来自于方差。



        上图表示，如果一个模型在训练集上正确率为 80%，测试集上正确率为 79% ，则模型欠拟合，其中 20% 的误差来自于偏差，1% 的误差来自于方差。如果一个模型在训练集上正确率为 99%，测试集上正确率为 80% ，则模型过拟合，其中 1% 的误差来自于偏差，19% 的误差来自于方差。

        可以看出，欠拟合是一种高偏差的情况。过拟合是一种低偏差，高方差的情况。

### 方差与偏差

偏差：预计值的期望与真实值之间的差距；
方差：预测值的离散程度，也就是离其期望值的距离。

### 验证集与交叉验证

 在机器学习中，通常需要评估若⼲候选模型的表现并从中选择模型。这⼀过程称为模型选择。可供选择的候选模型可以是有着不同超参数的同类模型。以神经网络为例，我们可以选择隐藏层的个数，学习率大小和激活函数。为了得到有效的模型，我们通常要在模型选择上下⼀番功夫。从严格意义上讲，测试集只能在所有超参数和模型参数选定后使用⼀次。不可以使用测试数据选择模型，如调参。由于无法从训练误差估计泛化误差，因此也不应只依赖训练数据选择模型。鉴于此，我们可以预留⼀部分在训练数据集和测试数据集以外的数据来进⾏模型选择。这部分数据被称为验证数据集，简称验证集。


K折交叉验证

## 分类算法与评估指标

### MSE

MSE(均方误差)是回归任务中最常用的性能度量，计算预测值与真实值之间误差的平方。

$$
MSE = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2
$$

### RMSE

RMSE(均方根误差)是MSE的平方根。

$$
RMSE = \sqrt{MSE}
$$

### MAE

MAE(平均绝对误差)是预测值与真实值之间绝对误差的平均值。

$$
MAE = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|
$$

### R-Squared

R-Squared(决定系数)是回归任务中最常用的性能度量，计算预测值与真实值之间的相关性。

$$
R^2 = 1 - \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}
$$

### precision, recall, F1-score

precision(精确率)是预测为正的样本中实际为正的比例。

$$
precision = \frac{TP}{TP + FP}
$$

recall(召回率)是实际为正的样本中预测为正的比例。


$$
recall = \frac{TP}{TP + FN}
$$

F1-score是精确率和召回率的调和平均值。

$$
F1-score = \frac{2 \times precision \times recall}{precision + recall}
$$

### auc, roc, pr曲线

auc(area under curve)是roc曲线下面积。

roc(receiver operating characteristic curve)是接收者操作特征曲线。

pr曲线是precision-recall曲线。

auc为什么适合排序问题？

## 损失函数与优化



1. https://blog.csdn.net/qingtianhaoshuai/article/details/124222008
2. https://blog.csdn.net/m0_72968288/article/details/143662769